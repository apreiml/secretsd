#!/usr/bin/env python3
from collections import defaultdict
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives.ciphers import Cipher
from cryptography.hazmat.primitives.ciphers.algorithms import AES
from cryptography.hazmat.primitives.ciphers.modes import CBC
from cryptography.hazmat.primitives.hashes import SHA256
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.padding import PKCS7
import dbus
import dbus.service
import dbus.mainloop.glib
from gi.repository import GLib
import logging
import os
import sqlite3
import time
import xdg.BaseDirectory

MODP1024_PRIME=0xffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff
MODP1024_GEN=2

MODP1024 = dh.DHParameterNumbers(p=MODP1024_PRIME, g=MODP1024_GEN)

NullObject = dbus.ObjectPath("/")

class Counter():
    def __init__(self, start):
        self.value = start

    def increment(self):
        v = self.value
        self.value += 1
        return v

class SecretsDatabase():
    def __init__(self, path):
        self.db = sqlite3.connect(path)
        self.initialize()

    def initialize(self):
        cur = self.db.cursor()
        cur.execute("CREATE TABLE IF NOT EXISTS items" \
                    " (object TEXT, label TEXT, created INTEGER, modified INTEGER)")
        cur.execute("CREATE TABLE IF NOT EXISTS attributes" \
                    " (object TEXT, attribute TEXT, value TEXT)")
        cur.execute("CREATE TABLE IF NOT EXISTS secrets " \
                    " (object TEXT, secret TEXT, type TEXT)")
        self.db.commit()

    def add_item(self, object, label, attrs, secret, sec_type):
        now = int(time.time())
        cur = self.db.cursor()
        cur.execute("INSERT INTO items VALUES (?,?,?,?)", (object, label, now, now))
        for key, val in attrs.items():
            cur.execute("INSERT INTO attributes VALUES (?,?,?)", (object, key, val))
        cur.execute("INSERT INTO secrets VALUES (?,?,?)", (object, secret, sec_type))
        self.db.commit()

    def find_items(self, match_attrs):
        qry = "SELECT object FROM attributes WHERE attribute = ? AND value = ?"
        qry = " INTERSECT ".join([qry] * len(match_attrs))
        parvs = []
        for k, v in match_attrs.items():
            parvs += [k, v]
        print("DB: searching for %r" % parvs)
        cur = self.db.cursor()
        cur.execute(qry, parvs)
        return [r[0] for r in cur.fetchall()]

    def get_metadata(self, object):
        print("DB: getting metadata for %r" % object)
        cur = self.db.cursor()
        cur.execute("SELECT label, created, modified FROM items WHERE object = ?",
                    (object,))
        return cur.fetchone()

    def get_attributes(self, object):
        print("DB: getting attrs for %r" % object)
        cur = self.db.cursor()
        cur.execute("SELECT attribute, value FROM attributes WHERE object = ?", (object,))
        return {k: v for k, v in cur.fetchall()}

    def get_value(self, object, attribute):
        print("DB: getting attr[%r] for %r" % (attribute, value))
        cur = self.db.cursor()
        cur.execute("SELECT value FROM attributes WHERE object = ? AND attribute = ?",
                    (object, attribute))
        return cur.fetchone()[0]

    def get_schema(self, object):
        return self.get_value(object, "xdg:schema")

    def get_secret(self, object):
        print("DB: getting secret for %r" % object)
        cur = self.db.cursor()
        cur.execute("SELECT secret, type FROM secrets WHERE object = ?", (object,))
        return cur.fetchone()

    def delete_item(self, object):
        print("DB: deleting item %r" % object)
        cur = self.db.cursor()
        cur.execute("DELETE FROM items WHERE object = ?", (object,))
        cur.execute("DELETE FROM attributes WHERE object = ?", (object,))
        cur.execute("DELETE FROM secrets WHERE object = ?", (object,))
        self.db.commit()

class SecretServiceSession(dbus.service.Object):
    ROOT = "/lt/nullroute/secretsd/session"
    PATH = "/lt/nullroute/secretsd/session/s%d"

    def __init__(self, service, bus_path, algorithm):
        self.bus_path = bus_path
        self.algorithm = algorithm
        self.kex_done = False
        self.crypt_key = None
        super().__init__(service.bus, bus_path)

    def kex(self, input):
        if self.algorithm == "plain":
            return (dbus.ByteArray(b""), True)
        elif self.algorithm == "dh-ietf1024-sha256-aes128-cbc-pkcs7":
            dh_params = MODP1024.parameters(default_backend())
            our_priv = dh_params.generate_private_key()
            peer_pubn = dh.DHPublicNumbers(int.from_bytes(input, "big"),
                                           MODP1024)
            peer_pub = peer_pubn.public_key(default_backend())
            shared_key = our_priv.exchange(peer_pub)
            kdf = HKDF(algorithm=SHA256(), length=128//8,
                       salt=b"", info=b"", backend=default_backend())
            derived_key = kdf.derive(shared_key)
            self.crypt_key = derived_key
            output = our_priv.public_key().public_numbers().y
            return (dbus.ByteArray(output.to_bytes(128, "big")), True)
        else:
            raise dbus.DBusException("org.freedesktop.DBus.Error.NotSupported")

    def encrypt(self, input):
        if self.algorithm == "plain":
            return input, None
        elif self.algorithm == "dh-ietf1024-sha256-aes128-cbc-pkcs7":
            key = self.crypt_key
            iv = os.urandom(AES.block_size//8)
            p = PKCS7(AES.block_size).padder()
            e = Cipher(AES(self.crypt_key), CBC(iv),
                       backend=default_backend()).encryptor()
            ct = p.update(input) + p.finalize()
            ct = e.update(ct) + e.finalize()
            return ct, iv

    def decrypt(self, input, iv):
        if self.algorithm == "plain":
            return input
        elif self.algorithm == "dh-ietf1024-sha256-aes128-cbc-pkcs7":
            key = self.crypt_key
            d = Cipher(AES(self.crypt_key), CBC(iv),
                       backend=default_backend()).decryptor()
            p = PKCS7(AES.block_size).unpadder()
            pt = d.update(input) + d.finalize()
            pt = p.update(pt) + p.finalize()
            return pt

class SecretServiceItem(dbus.service.Object):
    PATH = "/lt/nullroute/secretsd/item/i%d"

    def __init__(self, service, bus_path):
        self.service = service
        self.bus_path = bus_path
        super().__init__(service.bus, bus_path)

class SecretServiceItemFallback(dbus.service.FallbackObject):
    ROOT = "/lt/nullroute/secretsd/item"

    def __init__(self, service):
        self.service = service
        self.bus_path = self.ROOT
        super().__init__(self.service.bus, self.bus_path)

    def get_attributes(self, path):
        attrs = self.service.db.get_attributes(path)
        if "xdg:schema" not in attrs:
            attrs["xdg:schema"] = "org.foo"
        return attrs

    def get_label(self, path):
        meta = self.service.db.get_metadata(path)
        return meta[0]

    def get_schema(self, path):
        #schema = self.service.db.get_schema(path)
        schema = "org.foo"
        return schema

    def get_created(self, path):
        meta = self.service.db.get_metadata(path)
        return dbus.UInt64(meta[1])

    def get_modified(self, path):
        meta = self.service.db.get_metadata(path)
        if not meta:
            raise dbus.DBusException("uhh.something")
        return dbus.UInt64(meta[2])

    PROPERTIES = {
        "Attributes":   (get_attributes, None),
        "Created":      (get_created, None),
        "Label":        (get_label, None),
        "Locked":       (None, False),
        "Modified":     (get_modified, None),
        "Type":         (get_schema, None),
    }

    @dbus.service.method("org.freedesktop.Secret.Item", "", "o",
                         path_keyword="path")
    def Delete(self, path=None):
        self.service.db.delete_item(path)
        return NullObject

    @dbus.service.method("org.freedesktop.DBus.Properties", "s", "a{sv}",
                         path_keyword="path")
    def GetAll(self, interface, path=None):
        print("Item.GetAll(%r) at %r" % (interface, path))

        if interface == "org.freedesktop.Secret.Item":
            out = {}
            for name, (getter, value) in self.PROPERTIES.items():
                if getter:
                    value = getter(self, path)
                out[name] = value
            return out
        else:
            return {}

    @dbus.service.method("org.freedesktop.DBus.Properties", "ss", "v",
                         path_keyword="path")
    def Get(self, interface, property, path=None):
        print("TODO: Item.Get(%r, %r) at %r" % (interface, property, path))
        raise dbus.DBusException("org.freedesktop.DBus.Error.NotSupported")

class SecretServiceCollection(dbus.service.Object):
    SUPPORTS_MULTIPLE_OBJECT_PATHS = True

    PATH = "/lt/nullroute/secretsd/collection/s%d"

    def __init__(self, service, bus_path, alias, properties):
        self.service = service
        self.bus_path = bus_path
        self.alias = alias
        self.locked = False
        self.created = 0
        self.modified = 0
        self.label = None
        self.items = {}
        super().__init__(service.bus, bus_path)

    @dbus.service.method("org.freedesktop.Secret.Collection", "a{sv}(oayays)b", "oo",
                         sender_keyword="sender",
                         byte_arrays=True)
    def CreateItem(self, properties, secret, replace,
                   sender=None):
        label = properties["org.freedesktop.Secret.Item.Label"]
        attrs = properties["org.freedesktop.Secret.Item.Attributes"]

        sec_session, sec_param, sec_ct, sec_type = secret
        sec_session = self.service.path_objects[sec_session]
        sec_data = sec_session.decrypt(sec_ct, sec_param)

        bus_path = self.service.make_bus_path(SecretServiceItem)
        self.service.db.add_item(bus_path, label, attrs, sec_data, sec_type)

        return (dbus.ObjectPath(bus_path), NullObject)

    @dbus.service.method("org.freedesktop.Secret.Collection", "", "o")
    def Delete(self):
        print("TODO: Collection.Delete()")
        raise dbus.DBusException("org.freedesktop.DBus.Error.NotSupported")

    @dbus.service.method("org.freedesktop.Secret.Collection", "a{ss}", "ao")
    def SearchItems(self, attributes):
        print("TODO: Collection.SearchItems(%r)" % attributes)
        raise dbus.DBusException("org.freedesktop.DBus.Error.NotSupported")

    @dbus.service.signal("org.freedesktop.Secret.Collection", "o")
    def ItemChanged(self, bus_path):
        pass

    @dbus.service.signal("org.freedesktop.Secret.Collection", "o")
    def ItemCreated(self, bus_path):
        pass

    @dbus.service.signal("org.freedesktop.Secret.Collection", "o")
    def ItemDeleted(self, bus_path):
        pass

class SecretService(dbus.service.Object):
    def __init__(self, bus, sdb):
        self.bus = bus
        self.db = sdb
        self.bus_name = dbus.service.BusName("org.freedesktop.secrets", self.bus)
        self.path_objects = {}
        self.next_object = 0
        self.client_objects = defaultdict(list)
        self.collections = {}

        super().__init__(self.bus, "/org/freedesktop/secrets")

        self.fallback_item = SecretServiceItemFallback(self)

    def make_bus_path(self, type):
        bus_path = type.PATH % self.next_object
        self.next_object += 1
        return bus_path

    def make_unique(self, sender, type, *args, **kwargs):
        bus_path = type.PATH % self.next_object
        self.next_object += 1
        object = type(self, bus_path, *args, **kwargs)
        self.path_objects[bus_path] = object
        if sender:
            self.client_objects[sender].append(bus_path)
        return object

    def gc_client(self, sender):
        # TODO: hook this up
        if sender in self.client_objects:
            for path in self.client_objects[sender]:
                del self.path_objects[path]
            del self.client_objects[sender]

    def find_or_create_collection(self, alias, properties):
        if alias not in self.collections:
            col = self.make_unique(None, SecretServiceCollection, alias, properties)
            self.collections[alias] = col
            alias_path = "/org/freedesktop/secrets/aliases/%s" % alias
            col.add_to_connection(self.bus, alias_path)
            self.path_objects[alias_path] = col
        return self.collections[alias]

    ## bus methods

    @dbus.service.method("org.freedesktop.Secret.Service", "a{sv}s", "oo",
                         sender_keyword="sender")
    def CreateCollection(self, properties, alias,
                         sender=None):
        if alias != "default":
            print("CreateCollection(%r, %r)" % (properties, alias))
            raise dbus.DBusException("org.freedesktop.DBus.Error.NotSupported")
        collection = self.find_or_create_collection(alias, properties)
        return (dbus.ObjectPath(collection.bus_path), NullObject)

    @dbus.service.method("org.freedesktop.Secret.Service", "aoo", "a{o(oayays)}")
    def GetSecrets(self, items, session):
        session = self.path_objects[session]
        out = {}
        for item_path in items:
            sec_data, sec_type = self.db.get_secret(item_path)
            sec_ct, sec_iv = session.encrypt(sec_data)
            out[item_path] = (session.bus_path, sec_iv, sec_ct, sec_type)
        return out

    @dbus.service.method("org.freedesktop.Secret.Service", "sv", "vo",
                         sender_keyword="sender",
                         byte_arrays=True)
    def OpenSession(self, algorithm, input, sender=None):
        session = self.make_unique(sender, SecretServiceSession, algorithm)
        output, done = session.kex(input)
        if done:
            return (output, session.bus_path)
        else:
            return (output, NullObject)

    @dbus.service.method("org.freedesktop.Secret.Service", "a{ss}", "aoao")
    def SearchItems(self, attributes):
        unlocked = self.db.find_items(attributes)
        locked = []
        return (unlocked, locked)

    ## unimplemented

    @dbus.service.method("org.freedesktop.Secret.Service", "ao", "aoo")
    def Unlock(self, objects):
        return (objects, NullObject)

    @dbus.service.method("org.freedesktop.Secret.Service", "ao", "aoo")
    def Lock(self, objects):
        print("TODO: Service.Lock(%r)" % objects)
        raise dbus.DBusException("org.freedesktop.DBus.Error.NotSupported")

    @dbus.service.method("org.freedesktop.Secret.Service", "s", "o")
    def ReadAlias(self, name):
        print("TODO: Service.ReadAlias(%r)" % name)
        raise dbus.DBusException("org.freedesktop.DBus.Error.NotSupported")

    @dbus.service.method("org.freedesktop.Secret.Service", "so", "")
    def SetAlias(self, name, collection):
        print("TODO: Service.SetAlias(%r, %r)" % (name, collection))
        raise dbus.DBusException("org.freedesktop.DBus.Error.NotSupported")

os.umask(0o077)

db_dir = xdg.BaseDirectory.save_data_path("nullroute.eu.org")
db_path = os.path.join(db_dir, "secrets.db")

dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
bus = dbus.SessionBus()
sdb = SecretsDatabase(db_path)
svc = SecretService(bus, sdb)

loop = GLib.MainLoop()
loop.run()
